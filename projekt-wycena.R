# trzymanie drzew w macierzy zaczynamy od dolnego lewego rogu, potem macierz payoff, funkcja pmax po wektorach
# macierz ceny, macierz payoff, macierz maksimów
# w europejskiej zerujemy payoffy do ostatniego, bo dopiero na końcu wykonujemy
# w amerykańskiej nie zerujemy payofffów
# robimy funkcje payoff dla call i put


# nasze dane
d_t <- 1 / 12
sigma <- 0.3
u <- exp(sigma * sqrt(d_t))
d <- exp(-sigma * sqrt(d_t))    # d = 1 / u = u**(-1)
S_0 <- 50
r <- 0.02
K <- 48
T <- 2


binomial_tree <- function(S_0, u, d_t, T){
  
  N <- T / d_t    # liczba kroków w drzewie, rozmiar macierzy
  A <- matrix(NA, N, N)
  for (i in 1:N){
    A[N:(N - i + 1), i] <- u**(seq(-(i - 1), (i - 1), 2))
  }
  S_T <- S_0 * A
  
  return(S_T)
}

S_T <- model(S_0, u, d, r, K, d_t, T)

wycena <- function(u, d, r, d_t, V_u, V_d){
  
  p <- (exp(r * d_t) - d) / (u - d)
  return(exp(-r * d_t) * (p * V_u + (1 - p) * V_d))
}

european_option <- function(S_0, u, d, r, K, d_t, T, type = 'put'){
  
  N <- T / d_t    # liczba kroków w drzewie, rozmiar macierzy
  S_T <- binomial_tree(S_0, u, d_t, T)    # macierz w momencie S_t
  B <- matrix(0, N, N)    # macierz payoff
  B[is.na(S_T)] <- NA
  for (i in 1:N){
    if(type == 'put')
      B[i, N] <- max(K - S_T[i, N], 0)
    else
      B[i, N] <- max(S_T[i, N] - K, 0)
  }
  
  for (i in (k - 1):1){
    for (j in (k - i + 1):k){
      B[j, i] <- wycena(u, d, r, d_t, B[j - 1, i + 1], B[j, i + 1])
    }
  }
  
  return(B)
}

EU_put <- round(european_option(S_0, u, d, r, K, d_t, T, type = 'put')[T / d_t, 1], 2)    # zadanie 1
EU_call <- round(european_option(S_0, u, d, r, K, d_t, T, type = 'call')[T / d_t, 1], 2)


calla<-function(u,d,K,T,r,d_t,S_T){
  k <- T / d_t
  B <- matrix(NA, k, k)    # macierz payoff
  # for (i in 1:k){
  #  B[, k] <- pmax(S_T[, k]-K, 0) B[i, k] <- max(S_T[i, k] - K, 0)    # ostatnia kolumna, czyli payoff dla S_T
  # }
  # 
  B[, k] <- pmax(S_T[, k]-K, 0)
  
  for (i in (k - 1):1){
    for (j in (k - i + 1):k){
      a<-wycena(r,T,d,u,B[j - 1, i + 1], B[j, i + 1], d_t)
      b<-max(S_T[j, i]-K,0)
      B[j, i] <- max(a,b)
    }
  }
  return(B)
}

View(calla(u,d,K,T,r,d_t,S_T))


puta<-function(u,d,K,T,r,d_t,S_T){
  k <- T / d_t
  B <- matrix(NA, k, k)    # macierz payoff
  for (i in 1:k){
    B[i, k] <- max(K-S_T[i, k], 0)    # ostatnia kolumna, czyli payoff dla S_T
  }
  
  for (i in (k - 1):1){
    for (j in (k - i + 1):k){
      a <- wycena(r,T,d,u,B[j - 1, i + 1], B[j, i + 1])
      b<-max(K-S_T[j, i],0)
    B[j, i]<-max(a,b)
    }
  }
  return(B)
}

View(puta(u,d,K,T,r,d_t,S_T))


# badanie opłacalności? 

maksimum<-matrix(NA,k,k)

